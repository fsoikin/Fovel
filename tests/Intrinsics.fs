module Fovel.Tests.Intrinsics
open Xunit
open Fovel

let [<Fact>] ``Basic`` () = 
  let parseIntrinsic (fn: FSharp.fn) = if fn.LogicalName = "singleton" then Some() else None
  let intrinsicCode () args = "foo " + (String.concat "," args) + " bar"
  let config = 
    { Config.WithoutCoreLib with
        ParseIntrinsic = parseIntrinsic
        GenerateIntrinsicCode = intrinsicCode }

  compileCompareWithConfig config ""
    """
      module X
      let x = Seq.singleton 5 
    """
    """
      var x = { var _0 = 5 foo _0 bar } """


let [<Fact>] ``Code inside intrinsic definition isn't validated`` () = 
  let parseIntrinsic (fn: FSharp.fn) = if fn.LogicalName = "the_intrinsic" then Some() else None
  let intrinsicCode () _ = "foo"
  let config = 
    { Config.WithoutCoreLib with
        ParseIntrinsic = parseIntrinsic
        GenerateIntrinsicCode = intrinsicCode }

  compileCompareWithConfig config ""
    """
      module X
      let the_intrinsic x y : int = failwith "boo!"
      let x = the_intrinsic 5 6
    """
    """
      var x = { var _0 = 5 var _1 = 6 foo } """

let [<Fact>] ``Used as values`` () = 
  let parseIntrinsic (fn: FSharp.fn) = if fn.LogicalName.StartsWith "intr" then Some() else None
  let intrinsicCode () args = "foo( " + (String.concat ", " args) + " )"
  let config = 
    { Config.WithoutCoreLib with
        ParseIntrinsic = parseIntrinsic
        GenerateIntrinsicCode = intrinsicCode }

  compileCompareWithConfig config ""
    (*
      Usually the F# compiler will create an in-place lambda expression where a function is used as a value.
      For example, this:
        let f x = x+5
        let g = f
      Will be parsed as "g = fun x -> f x"

      But in _some_ cases, it will generate a genuine SymRef (i.e. "g = f") instead.
      I'm not quite sure what these "some cases" are, but I found at least one, and it is below.
    *)
    """
      module X
      let inline ap f x y = f x y
      let intr1 (x: string) (y: int) : unit = failwith ""
      let intr2 (x: string, y: int) (z: bool) : unit = failwith ""
      ap intr1 "a" 0
      ap intr2 ("b", 5) true
    """
    """
      {
	      var f = {fn(x__1) fn(y__1) { var _0 = x__1 var _1 = y__1 foo( _0, _1 ) }}
	      var x = {'a'}
	      var y = {0}
	      {{f}(x)}(y)}
      {
	      var f = {fn(tupledArg) {
		      var x__2 = {{tupledArg}[0]}
		      var y__2 = {{tupledArg}[1]}
		      fn(z) { var _0 = x__2 var _1 = y__2 var _2 = z foo( _0, _1, _2 ) }}}
	      var x = {array( 'b', 5 )}
	      var y = {true}
	      {{f}(x)}(y)} """


type UdpDef = UdpDef of string

let [<Fact>] ``UDP proof-of-concept`` () = 
  (*
    This test is a proof-of-concept demonstration of how Shovel UDPs should be handled.
    
    The general idea here is that UDPs are modeled as intrinsics. The consuming code
    should be able to recognize the UDPs somehow (in the example below, I use attributes),
    and provide two functions, one for recognizing (ParseIntrinsic) and one for code
    generation (GenerateIntrinsicCode). The recognizer function returns some type that
    encapsulates whatever information about the intrinsic is important for code generation,
    and that type becomes part of the parsed expression (mentioned in the Expr<> type as 'Intrinsic).
    During code generation, this information will be passed to the code generation function. 

    In the example below, the `parseIntrinsic` function looks to see if the function in question
    is maked with UdpAttribute, in which case it is assumed to represent a UDP, and an UdpDef
    is returned.
    The `intrinsicCode` function accepts a UdpDef instance and generates code calling the UDP.

    Note that in this example the name of the function as defined in F# source is translated
    to the UDP name verbatim. A more complex implementation may allow explicitly specifying
    the UDP name, for example as the UdpAttribute's constructor argument:

        [<Udp "MyUdp">]
        let callMyUdp (x: int) : string = falwith ""
    
    The bodies of these functions do not matter, as they are discarded in favor of the code
    generated by the `intrinsicCode` function, but since the F# compiler won't allow an empty
    body, we use `failwith` as filler.
  *)

  let parseIntrinsic (fn: FSharp.fn) = 
    if fn.Attributes |> Seq.exists (fun a -> a.AttributeType.LogicalName = "UdpAttribute") 
    then Some (UdpDef fn.LogicalName)
    else None

  let intrinsicCode (UdpDef name) args = sprintf "@%s( %s )" name (String.concat ", " args)
  let config = 
    { Config.FSharpPrelude = None
      ReplaceFunctions = fun _ -> id
      ParseIntrinsic = parseIntrinsic
      GenerateIntrinsicCode = intrinsicCode }

  compileCompareWithConfig config ""
    """
      module X

      type UdpAttribute() = inherit System.Attribute()

      [<Udp>]
      let udp1 (x: string) (y: int) : unit = failwith ""

      [<Udp>]
      let udp2 (x: string, y: int) (z: bool) : unit = failwith ""

      udp1 "abc" 42
      udp2 ("xyz", 42) false
    """
    """
      { var _0 = 'abc' var _1 = 42 @udp1( _0, _1 ) }
      { var _0 = 'xyz' var _1 = 42 var _2 = false @udp2( _0, _1, _2 ) }
    """